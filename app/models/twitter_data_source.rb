#
# microphisher - a spear phishing support tool
#
# Created by Ulisses Albuquerque & Joaquim Espinhara
# Copyright (C) 2013 Trustwave Holdings, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

class TwitterDataSource < DataSource
  include Mongoid::Document
  
  # Callbacks
  before_validation do |document|
    self.data_source_metadata = user_information(user_id)
  end

  # Validations
  validates :user_id, presence: true
  validate :valid_twitter_user

  def valid_twitter_user
    if data_source_metadata.has_key?('errors')
      errors.add(:user_id, "#{user_id} is not a valid Twitter user")
    end
  end
  
  def twitter_profile_url
    "https://www.twitter.com/#{user_id}"
  end

  def fetch_status_updates!
    self.set(:status, 'indexing')
    
    begin
      self.tweets(self.user_id) do |tweet|
        unless status_updates.find_by(id_str: tweet['id_str'])
          # HACK: We skip the ID attribute because those should be
          # autogenerated by Mongoid/MongoDB, otherwise relations do
          # not work properly
          status_update = status_updates.new
          tweet.each { |k,v| status_update[k] = v unless k.match(/^id$/) }
          status_update.save
        end
      end
    rescue Exception => exception
      logger.error("Exception indexing #{self.user_id}: #{exception.to_s}")
    end
    
    self.set(:status, 'complete')
    self.set(:last_crawl, DateTime.now)
    self.save!
  end

  protected
  USER_TIMELINE_SIZE = 200
  USER_TIMELINE_PATH = '/1.1/statuses/user_timeline.json'
  USER_INFORMATION_PATH = '/1.1/users/show.json'
  
  # TODO: Proper error handling
  # TODO: Twitter only returns the latest 3,200 tweets for a given
  # user timeline; is there some way to overcome this?
  def tweets(username)
    access_token = unknown_subject.user.access_token
    tweet_request = self._tweets_request(username)
    tweet_list_json = access_token.get(tweet_request).body
    tweet_list = JSON.parse(tweet_list_json)
    
    # TODO: We should act proactively in order to avoid being
    # rate limited; Twitter explicitly mentions applications which
    # consistently exceed rate limiting will be blacklisted
    while tweet_list.size > 0 && tweet_list.first['errors'].nil?
      tweet_list.each { |tweet| yield tweet }
      max_id = tweet_list.min_by { |tweet| tweet['id'].to_i }['id']
      tweet_request = self._tweets_request(username, max_id)
      tweet_list_json = access_token.get(tweet_request).body
      tweet_list = JSON.parse(tweet_list_json)
    end
  end
  
  def user_information(screen_name)
    access_token = unknown_subject.user.access_token
    user_request = self._user_information_request(screen_name)
    user_information_json = access_token.get(user_request).body
    JSON.parse(user_information_json)
  end

  def _tweets_request(username, max_id = nil)
    get_parameters = { 'screen_name' => username, 'count' => USER_TIMELINE_SIZE }
    get_parameters['max_id'] = max_id unless max_id.nil?
    get_request = Net::HTTP::Get.new(USER_TIMELINE_PATH)
    get_request.set_form_data(get_parameters)
    "#{USER_TIMELINE_PATH}?#{get_request.body}"
  end
  
  def _user_information_request(screen_name)
    get_parameters = { 'screen_name' => screen_name }
    get_request = Net::HTTP::Get.new(USER_INFORMATION_PATH)
    get_request.set_form_data(get_parameters)
    "#{USER_INFORMATION_PATH}?#{get_request.body}"
  end
end

